import t from"splaytree";import{orient2d as e}from"robust-predicates";const n=(t,e)=>t.ll.x<=e.x&&e.x<=t.ur.x&&t.ll.y<=e.y&&e.y<=t.ur.y,i=(t,e)=>{if(e.ur.x<t.ll.x||t.ur.x<e.ll.x||e.ur.y<t.ll.y||t.ur.y<e.ll.y)return null;const n=t.ll.x<e.ll.x?e.ll.x:t.ll.x,i=t.ur.x<e.ur.x?t.ur.x:e.ur.x;return{ll:{x:n,y:t.ll.y<e.ll.y?e.ll.y:t.ll.y},ur:{x:i,y:t.ur.y<e.ur.y?t.ur.y:e.ur.y}}};let s=Number.EPSILON;void 0===s&&(s=Math.pow(2,-52));const r=s*s,o=(t,e)=>{if(-s<t&&t<s&&-s<e&&e<s)return 0;const n=t-e;return n*n<r*t*e?0:t<e?-1:1};class l{constructor(){this.tree=new t,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(null!==n&&0===o(e.key,n.key))return this.tree.remove(t),n.key;const i=this.tree.next(e);return null!==i&&0===o(e.key,i.key)?(this.tree.remove(t),i.key):t}}const h=new class{constructor(){this.reset()}reset(){this.xRounder=new l,this.yRounder=new l}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}},u=(t,e)=>t.x*e.y-t.y*e.x,p=(t,e)=>t.x*e.x+t.y*e.y,c=(t,n,i)=>{const s=e(t.x,t.y,n.x,n.y,i.x,i.y);return s>0?-1:s<0?1:0},g=t=>Math.sqrt(p(t,t)),f=(t,e,n)=>{const i={x:e.x-t.x,y:e.y-t.y},s={x:n.x-t.x,y:n.y-t.y};return u(s,i)/g(s)/g(i)},y=(t,e,n)=>{const i={x:e.x-t.x,y:e.y-t.y},s={x:n.x-t.x,y:n.y-t.y};return p(s,i)/g(s)/g(i)},x=(t,e,n)=>0===e.y?null:{x:t.x+e.x/e.y*(n-t.y),y:n},a=(t,e,n)=>0===e.x?null:{x:n,y:t.y+e.y/e.x*(n-t.x)};class E{static compare(t,e){const n=E.comparePoints(t.point,e.point);return 0!==n?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:m.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){void 0===t.events?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let t=0,n=e.length;t<n;t++){const n=e[t];this.point.events.push(n),n.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(void 0===n.segment.consumedBy)for(let i=e+1;i<t;i++){const t=this.point.events[i];void 0===t.consumedBy&&n.otherSE.point.events===t.otherSE.point.events&&n.segment.consume(t.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const n=this.point.events[e];n!==this&&!n.segment.ringOut&&n.segment.isInResult()&&t.push(n)}return t}getLeftmostComparator(t){const e=new Map,n=n=>{const i=n.otherSE;e.set(n,{sine:f(this.point,t.point,i.point),cosine:y(this.point,t.point,i.point)})};return(t,i)=>{e.has(t)||n(t),e.has(i)||n(i);const{sine:s,cosine:r}=e.get(t),{sine:o,cosine:l}=e.get(i);return s>=0&&o>=0?r<l?1:r>l?-1:0:s<0&&o<0?r<l?-1:r>l?1:0:o<s?-1:o>s?1:0}}}let b=0;class m{static compare(t,e){const n=t.leftSE.point.x,i=e.leftSE.point.x,s=t.rightSE.point.x,r=e.rightSE.point.x;if(r<n)return 1;if(s<i)return-1;const o=t.leftSE.point.y,l=e.leftSE.point.y,h=t.rightSE.point.y,u=e.rightSE.point.y;if(n<i){if(l<o&&l<h)return 1;if(l>o&&l>h)return-1;const n=t.comparePoint(e.leftSE.point);if(n<0)return 1;if(n>0)return-1;const i=e.comparePoint(t.rightSE.point);return 0!==i?i:-1}if(n>i){if(o<l&&o<u)return-1;if(o>l&&o>u)return 1;const n=e.comparePoint(t.leftSE.point);if(0!==n)return n;const i=t.comparePoint(e.rightSE.point);return i<0?1:i>0?-1:1}if(o<l)return-1;if(o>l)return 1;if(s<r){const n=e.comparePoint(t.rightSE.point);if(0!==n)return n}if(s>r){const n=t.comparePoint(e.rightSE.point);if(n<0)return 1;if(n>0)return-1}if(s!==r){const t=h-o,e=s-n,p=u-l,c=r-i;if(t>e&&p<c)return 1;if(t<e&&p>c)return-1}return s>r?1:s<r||h<u?-1:h>u?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,i){this.id=++b,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=i}static fromRing(t,e,n){let i,s,r;const o=E.comparePoints(t,e);if(o<0)i=t,s=e,r=1;else{if(!(o>0))throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);i=e,s=t,r=-1}const l=new E(i,!0),h=new E(s,!1);return new m(l,h,[n],[r])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,i=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const s=(t.y-e.y)/i.y,r=e.x+s*i.x;if(t.x===r)return 0;const o=(t.x-e.x)/i.x,l=e.y+o*i.y;return t.y===l?0:t.y<l?-1:1}getIntersection(t){const e=this.bbox(),s=t.bbox(),r=i(e,s);if(null===r)return null;const o=this.leftSE.point,l=this.rightSE.point,p=t.leftSE.point,c=t.rightSE.point,g=n(e,p)&&0===this.comparePoint(p),f=n(s,o)&&0===t.comparePoint(o),y=n(e,c)&&0===this.comparePoint(c),E=n(s,l)&&0===t.comparePoint(l);if(f&&g)return E&&!y?l:!E&&y?c:null;if(f)return y&&o.x===c.x&&o.y===c.y?null:o;if(g)return E&&l.x===p.x&&l.y===p.y?null:p;if(E&&y)return null;if(E)return l;if(y)return c;const b=((t,e,n,i)=>{if(0===e.x)return a(n,i,t.x);if(0===i.x)return a(t,e,n.x);if(0===e.y)return x(n,i,t.y);if(0===i.y)return x(t,e,n.y);const s=u(e,i);if(0==s)return null;const r={x:n.x-t.x,y:n.y-t.y},o=u(r,e)/s,l=u(r,i)/s;return{x:(t.x+l*e.x+(n.x+o*i.x))/2,y:(t.y+l*e.y+(n.y+o*i.y))/2}})(o,this.vector(),p,t.vector());return null===b?null:n(r,b)?h.round(b.x,b.y):null}split(t){const e=[],n=void 0!==t.events,i=new E(t,!0),s=new E(t,!1),r=this.rightSE;this.replaceRightSE(s),e.push(s),e.push(i);const o=new m(i,r,this.rings.slice(),this.windings.slice());return E.comparePoints(o.leftSE.point,o.rightSE.point)>0&&o.swapEvents(),E.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(i.checkForConsuming(),s.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let t=0,e=this.windings.length;t<e;t++)this.windings[t]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const i=m.compare(e,n);if(0!==i){if(i>0){const t=e;e=n,n=t}if(e.prev===n){const t=e;e=n,n=t}for(let t=0,i=n.rings.length;t<i;t++){const i=n.rings[t],s=n.windings[t],r=e.rings.indexOf(i);-1===r?(e.rings.push(i),e.windings.push(s)):e.windings[r]+=s}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return void 0!==this._prevInResult||(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null),this._prevInResult}beforeState(){if(void 0!==this._beforeState)return this._beforeState;if(this.prev){const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}else this._beforeState={rings:[],windings:[],multiPolys:[]};return this._beforeState}afterState(){if(void 0!==this._afterState)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,i=this._afterState.multiPolys;for(let t=0,i=this.rings.length;t<i;t++){const i=this.rings[t],s=this.windings[t],r=e.indexOf(i);-1===r?(e.push(i),n.push(s)):n[r]+=s}const s=[],r=[];for(let t=0,i=e.length;t<i;t++){if(0===n[t])continue;const i=e[t],o=i.poly;if(-1===r.indexOf(o))if(i.isExterior)s.push(o);else{-1===r.indexOf(o)&&r.push(o);const t=s.indexOf(i.poly);-1!==t&&s.splice(t,1)}}for(let t=0,e=s.length;t<e;t++){const e=s[t].multiPoly;-1===i.indexOf(e)&&i.push(e)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(void 0!==this._isInResult)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(O.type){case"union":{const n=0===t.length,i=0===e.length;this._isInResult=n!==i;break}case"intersection":{let n,i;t.length<e.length?(n=t.length,i=e.length):(n=e.length,i=t.length),this._isInResult=i===O.numMultiPolys&&n<i;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2==1;break}case"difference":{const n=t=>1===t.length&&t[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${O.type}`)}return this._isInResult}}class S{constructor(t,e,n){if(!Array.isArray(t)||0===t.length)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],"number"!=typeof t[0][0]||"number"!=typeof t[0][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const i=h.round(t[0][0],t[0][1]);this.bbox={ll:{x:i.x,y:i.y},ur:{x:i.x,y:i.y}};let s=i;for(let e=1,n=t.length;e<n;e++){if("number"!=typeof t[e][0]||"number"!=typeof t[e][1])throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let n=h.round(t[e][0],t[e][1]);n.x===s.x&&n.y===s.y||(this.segments.push(m.fromRing(s,n,this)),n.x<this.bbox.ll.x&&(this.bbox.ll.x=n.x),n.y<this.bbox.ll.y&&(this.bbox.ll.y=n.y),n.x>this.bbox.ur.x&&(this.bbox.ur.x=n.x),n.y>this.bbox.ur.y&&(this.bbox.ur.y=n.y),s=n)}i.x===s.x&&i.y===s.y||this.segments.push(m.fromRing(s,i,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const n=this.segments[e];t.push(n.leftSE),t.push(n.rightSE)}return t}}class d{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new S(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let e=1,n=t.length;e<n;e++){const n=new S(t[e],this,!1);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.interiorRings.push(n)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getSweepEvents();for(let e=0,i=n.length;e<i;e++)t.push(n[e])}return t}}class v{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{"number"==typeof t[0][0][0]&&(t=[t])}catch(t){}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let e=0,n=t.length;e<n;e++){const n=new d(t[e],this);n.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=n.bbox.ll.x),n.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=n.bbox.ll.y),n.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=n.bbox.ur.x),n.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=n.bbox.ur.y),this.polys.push(n)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getSweepEvents();for(let e=0,i=n.length;e<i;e++)t.push(n[e])}return t}}class w{static factory(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];if(!i.isInResult()||i.ringOut)continue;let s=null,r=i.leftSE,o=i.rightSE;const l=[r],h=r.point,u=[];for(;s=r,r=o,l.push(r),r.point!==h;)for(;;){const t=r.getAvailableLinkedEvents();if(0===t.length){const t=l[0].point,e=l[l.length-1].point;throw new Error(`Unable to complete output ring starting at [${t.x}, ${t.y}]. Last matching segment found ends at [${e.x}, ${e.y}].`)}if(1===t.length){o=t[0].otherSE;break}let n=null;for(let t=0,e=u.length;t<e;t++)if(u[t].point===r.point){n=t;break}if(null!==n){const t=u.splice(n)[0],i=l.splice(t.index);i.unshift(i[0].otherSE),e.push(new w(i.reverse()));continue}u.push({index:l.length,point:r.point});const i=r.getLeftmostComparator(s);o=t.sort(i)[0].otherSE;break}e.push(new w(l))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let n=1,i=this.events.length-1;n<i;n++){const i=this.events[n].point,s=this.events[n+1].point;0!==c(i,t,s)&&(e.push(i),t=i)}if(1===e.length)return null;const n=e[0],i=e[1];0===c(n,t,i)&&e.shift(),e.push(e[0]);const s=this.isExteriorRing()?1:-1,r=this.isExteriorRing()?0:e.length-1,o=this.isExteriorRing()?e.length:-1,l=[];for(let t=r;t!=o;t+=s)l.push([e[t].x,e[t].y]);return l}isExteriorRing(){if(void 0===this._isExteriorRing){const t=this.enclosingRing();this._isExteriorRing=!t||!t.isExteriorRing()}return this._isExteriorRing}enclosingRing(){return void 0===this._enclosingRing&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let e=1,n=this.events.length;e<n;e++){const n=this.events[e];E.compare(t,n)>0&&(t=n)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class R{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(null===t[0])return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const n=this.interiorRings[e].getGeom();null!==n&&t.push(n)}return t}}class I{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const n=this.polys[e].getGeom();null!==n&&t.push(n)}return t}_composePolys(t){const e=[];for(let n=0,i=t.length;n<i;n++){const i=t[n];if(!i.poly)if(i.isExteriorRing())e.push(new R(i));else{const t=i.enclosingRing();t.poly||e.push(new R(t)),t.poly.addInterior(i)}}return e}}class _{constructor(e,n=m.compare){this.queue=e,this.tree=new t(n),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const i=t.isLeft?this.tree.add(e):this.tree.find(e);if(!i)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let s,r,o=i,l=i;for(;void 0===s;)o=this.tree.prev(o),null===o?s=null:void 0===o.key.consumedBy&&(s=o.key);for(;void 0===r;)l=this.tree.next(l),null===l?r=null:void 0===l.key.consumedBy&&(r=l.key);if(t.isLeft){let i=null;if(s){const t=s.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(i=t),!s.isAnEndpoint(t))){const e=this._splitSafely(s,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}let o=null;if(r){const t=r.getIntersection(e);if(null!==t&&(e.isAnEndpoint(t)||(o=t),!r.isAnEndpoint(t))){const e=this._splitSafely(r,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}if(null!==i||null!==o){let t=null;t=null===i?o:null===o||E.comparePoints(i,o)<=0?i:o,this.queue.remove(e.rightSE),n.push(e.rightSE);const s=e.split(t);for(let t=0,e=s.length;t<e;t++)n.push(s[t])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=s)}else{if(s&&r){const t=s.getIntersection(r);if(null!==t){if(!s.isAnEndpoint(t)){const e=this._splitSafely(s,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}if(!r.isAnEndpoint(t)){const e=this._splitSafely(r,t);for(let t=0,i=e.length;t<i;t++)n.push(e[t])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const i=t.split(e);return i.push(n),void 0===t.consumedBy&&this.tree.add(t),i}}const P="undefined"!=typeof process&&process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,k="undefined"!=typeof process&&process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6,O=new class{run(e,n,s){O.type=e,h.reset();const r=[new v(n,!0)];for(let t=0,e=s.length;t<e;t++)r.push(new v(s[t],!1));if(O.numMultiPolys=r.length,"difference"===O.type){const t=r[0];let e=1;for(;e<r.length;)null!==i(r[e].bbox,t.bbox)?e++:r.splice(e,1)}if("intersection"===O.type)for(let t=0,e=r.length;t<e;t++){const e=r[t];for(let n=t+1,s=r.length;n<s;n++)if(null===i(e.bbox,r[n].bbox))return[]}const o=new t(E.compare);for(let t=0,e=r.length;t<e;t++){const e=r[t].getSweepEvents();for(let t=0,n=e.length;t<n;t++)if(o.insert(e[t]),o.size>P)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const l=new _(o);let u=o.size,p=o.pop();for(;p;){const t=p.key;if(o.size===u){const e=t.segment;throw new Error(`Unable to pop() ${t.isLeft?"left":"right"} SweepEvent [${t.point.x}, ${t.point.y}] from segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] from queue.`)}if(o.size>P)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(l.segments.length>k)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const e=l.process(t);for(let t=0,n=e.length;t<n;t++){const n=e[t];void 0===n.consumedBy&&o.insert(n)}u=o.size,p=o.pop()}h.reset();const c=w.factory(l.segments);return new I(c).getGeom()}};var L={union:(t,...e)=>O.run("union",t,e),intersection:(t,...e)=>O.run("intersection",t,e),xor:(t,...e)=>O.run("xor",t,e),difference:(t,...e)=>O.run("difference",t,e)};export{L as default};
